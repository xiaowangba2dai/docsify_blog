## 事务是什么？

事务是一个最小的不可分割的数据库操作序列。

事务能够保证一个业务的完整性。

`其执行的结果必须使数据库从一种一致性的状态变到另一种一致性的状态。`

`update user set money=money-100 where name="a";`

`update user set money=money+100 where name="b";`

多条sql语句，要么同时成功，要么同时失败。

## 事务开启和提交

mysql `默认开启事务`

```mysql
mysql> select @@autocommit;
+--------------+
| @@autocommit |
+--------------+
|            1 |
+--------------+
```

**事务开启**

`set autocommit=0;` 或`begin`或者 `start transaction`

加了之后可以回滚。

**事务手动提交：**`commit`

**事务手动回滚：**`rollback`

## 事务的四大特征

A 原子性：事务中的所有操作作为一个整体像原子一样不可以再分割，要么全部成功，要么全部失败。如转账操作是一个不可分割的操作。

C 一致性：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。

I 隔离性：并发执行的事务不能互相影响。

D 持久性：事务一旦提交，对数据库的更新都是持久的。

## 如何实现原子性

`日志恢复技术`保证了事务的原子性，使一致性状态不会因为事务或系统故障被破坏。

undo log 实现了事务的原子性，在innodb中，还实现了多版本并发控制（mvcc）

在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为undo log）。然后进行数据的修改，如果出现了错误或者用户执行了回滚，系统可以利用undo log中的备份将数据恢复到事务开始之前的状态。

## 事务的隔离级别

**如何查看数据库的隔离级别？**

系统级别：

`select @@global.transaction_isolation;`

会话级别：

`select @@tx_isolation;`

**如何修改隔离级别？**

`set transaction isolation level read uncommitted;`

**1. read uncommitted 读未提交的**

最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。

如果有事务a和事务b，a事务对数据进行操作，在操作的过程中，事务没有被提交，但是b可以看见a操作的结果。

这样就会出现（`脏读`）：一个事务读到了另外一个事务没有提交的数据。

某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

**2. read committed 读已经提交的**

允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。

虽然我只能读到另外一个事务提交的数据 ，但还是会出现问题，就是

读取同一个表的数据，发现前后不一致。

`不可重复读现象：`

在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

**3. repeatable read 可以重复读**

对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。

`幻读：`事务a和事务b同时操作一张表，事务a提交的数据，也不能被事务b读到，就可以造成幻读。

在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

**4. serializable 串行化** 

最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

当表被另外一个事务操作的时候，其他事务里面的写操作，是不可以进行的。

进入排队状态，只有在另外的事务结束之后，这边的写入操作才会执行。

`性能特差！`