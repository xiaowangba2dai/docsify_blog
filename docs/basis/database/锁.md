## 对MySQL的锁了解吗？

当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。

就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。

## 隔离级别与锁的关系

Read committed： `只会把查出来的行加锁`， 可以插入。

为什么？行锁，没有必要把没有查出来的行加锁。

（1）查询时使用的是`主键`，只需要在主键值对应的那一条数据加锁即可。

（2）查询使用的`唯一索引`，也是一样。

（3）查询使用的`普通索引`，。

（4）如果`不用索引`，也是一样。

Repeatable read （mysql默认隔离级别）： 间隙锁，插不进去

查询使用的`普通索引`，会把间隙也加锁，防止幻读，直接让你插到插不进去。

## 按照锁的类型数据库锁有哪些？

读锁：共享锁。当用户要进行数据的读取时，对数据加上共享锁。`共享锁可以同时加上多个`。

写锁：排它锁。当用户要进行数据的写入时，对数据加上排他锁。`排他锁只可以加一个`，他和其他的排他锁，共享锁都相斥。

用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

## 读操作

对于普通select语句，innodb不会加任何锁

## select ... lock in share mode

读出数据后，其他事务不能修改，但是自己也不一定能修改，因为其他事务也可以使用相同的方法继续加读锁。

## select ... for update

读出数据后，其他事务既不能写，也不能加读锁，只有自己可以修改数据。

## 写操作

delete: 

insert: 

update:

也会加写锁。

## 按照锁的粒度分数据库锁有哪些？

在关系型数据库中，可以**按照锁的粒度把数据库锁分**为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁

## 行锁

行级锁是Mysql中锁定粒度最细的一种锁，表示`只针对当前操作的行进行加锁`。

行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。`行级锁分为共享锁 和 排他锁`。

特点：开销大，加锁慢；`会出现死锁`；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

只有明确指定主键，才会执行行锁，否则执行表锁。

select * from user where id = 1 for update;

select * from user where id = 1 and name='kkk' for update;

**行锁机制：**

（1）Record Lock（普通行锁）：某个行记录上的锁

（2）Gap Lock（间隙锁）：锁定一个范围，但不包括记录本身。

（3）Next-key Lock（行&间隙）：锁定一个范围，并且锁定记录本身。`可以解决幻读问题`。

```mysql
# id 只有50

select * from user id > 49 for update;
```

## 表锁

表级锁是MySQL中锁定粒度最大的一种锁，`表示对当前操作的整张表加锁`，它`实现简单，资源消耗较少`，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

主键不明确

select * from user where name = 'kkk' for update;

select * from user where id <> for update;

**表锁机制：**

（1）意向锁

当一个事务带着表锁去访问一个被加了行锁的资源。那么行锁就会升级成意向锁。将表锁住。

```mysql
# 事务A
select * from user where id = 10 for update;

# 事务B
select * from user where name = 'kkk' for update;
```

（2）自增锁

事务插入自增类型的列时，获取自增锁。

如果一个事务正在往表里插入自增记录，其他事务都必须等待。

## InnoDB的行锁是怎么实现的？

答：InnoDB是基于索引来完成行锁

例: select * from tab_with_index where id = 1 for update;

for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起

## InnoDB存储引擎的锁的算法有三种

Record lock：单个行记录上的锁

Gap lock：间隙锁，锁定一个范围，不包括记录本身

Next-key lock：record+gap 锁定一个范围，包含记录本身

## 什么是死锁？怎么解决？

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁